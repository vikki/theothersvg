<html>
<head>
<script src="static/scripts/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="static/scripts/webgl-utils.js"></script>
<script type="text/javascript" src="static/scripts/planet.js"></script>
<script type="text/javascript" src="static/scripts/camera.js"></script>
<script type="text/javascript" src="static/scripts/vixgl.js"></script>
<script type="text/javascript" src="static/scripts/utils.js"></script>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    uniform sampler2D uSampler;
    uniform vec3 uGreyingFactor;

    void main (void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting * uGreyingFactor, textureColor.a);
    }
</script>

<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform float uScale;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, uScale);
      vTextureCoord = aTextureCoord;

      vec3 transformedNormal = uNMatrix * aVertexNormal;
      float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
      vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
    }
</script>


<script id="dummyFragmentShader" type="x-shader/x-fragment">
    precision mediump float;

    uniform vec4 uColor;

    void main(void) {
        gl_FragColor = uColor;
    }
</script>

<script id="dummyVertexShader" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform float uScale;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, uScale);
    }
</script>

<script>
    var dummy = new glCtx('dummygl', 'dummyFragmentShader', 'dummyVertexShader');
    var proper = new glCtx('vixgl', 'fragmentShader', 'vertexShader');

    dummy.initTextures = function()  {
    };

   var drawStuff = function(vvc) {
       initWorldObjects(vvc);

       dummy.drawStuff();
       proper.drawStuff(); 

       tick();
    };

    var lastTime = 0;
    var animate = function() {
       var timeNow = new Date().getTime();

       if (lastTime != 0){
          var elapsed = timeNow - lastTime;
          for (var i in planets) {
             planets[i].animate(elapsed); 
          }

          // TODO aiee gonna have to use mixins for this to avoid dependency....
          updateViewingAngle(elapsed);
       }

       lastTime = timeNow;
    };

    // ask the browser to call us again, next time stuff needs to be animated
    // i.e. when we're in focus and the screen needs repainting
    // then draw the scene, and set it up for next time (move things) 
    var tick = function() {
         requestAnimFrame(tick);
         handleKeys(); 
         proper.drawScene();
         dummy.drawScene();
         animate(); 
    }

    // internal func
    var getShader = function(ctx, shaderName) {
       var shaderScript = document.getElementById(shaderName);
         var str = '';
         for (var k = shaderScript.firstChild; k; k = k.nextSibling) {
            if (k.nodeType == 3) {
               str += k.textContent;
            }   
         }

         var shaderMap = {};
         shaderMap['x-shader/x-fragment'] = ctx.FRAGMENT_SHADER;
         shaderMap['x-shader/x-vertex']   = ctx.VERTEX_SHADER;
         
         var shader = ctx.createShader(shaderMap[shaderScript.type]);
         console.dir(shader);
         ctx.shaderSource(shader, str);
         ctx.compileShader(shader);

         if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)){
                 console.log(ctx.getShaderInfoLog(shader));
         } 

         return shader;
    };

    proper.initUniforms = function() {
       var shaderProgram = this.shaderProgram;
       var gl = this.gl;
       shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
       shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
       shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, 'uNMatrix');
       shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
       shaderProgram.scale = gl.getUniformLocation(shaderProgram, 'uScale');
       shaderProgram.greyingFactor = gl.getUniformLocation(shaderProgram, 'uGreyingFactor');
       shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, 'uAmbientColor');
       shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, 'uLightingDirection');
       shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, 'uDirectionalColor');
    }

    proper.initAttributes = function() {
       var prog = this.shaderProgram;
       var gl = this.gl;
       prog.vertexPositionAttribute = gl.getAttribLocation(prog, 'aVertexPosition');
       gl.enableVertexAttribArray(prog.vertexPositionAttribute);

       prog.vertexNormalAttribute = gl.getAttribLocation(prog, 'aVertexNormal');
       gl.enableVertexAttribArray(prog.vertexNormalAttribute);

       prog.textureCoordAttribute = gl.getAttribLocation(prog, 'aTextureCoord');
       gl.enableVertexAttribArray(prog.textureCoordAttribute);
    }

       proper.initProgVars = function(planet){
         var gl = this.gl;
         var vertices = this.vertices;
         var prog = this.shaderProgram;

         gl.bindBuffer(gl.ARRAY_BUFFER, vertices.normalBuffer);
         gl.vertexAttribPointer(prog.vertexNormalAttribute, vertices.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

         gl.bindBuffer(gl.ARRAY_BUFFER, vertices.textureCoordBuffer);
         gl.vertexAttribPointer(prog.textureCoordAttribute, vertices.textureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

         gl.activeTexture(gl.TEXTURE0);
         gl.bindTexture(gl.TEXTURE_2D, planet.texture);
         gl.uniform1i(prog.samplerUniform, 0);

         // push ambient light RGB uniform to shader
         gl.uniform3f( prog.ambientColorUniform, 0.2, 0.2, 0.2);

         // directional lighting vector
         var lightingDirection = [0.25, -0.25, -1.0];
         var adjustedLD = vec3.create();
         vec3.normalize(lightingDirection, adjustedLD);
         // reverse the vector cos we specify it in terms of where its going
         // but we calculate it in terms of where its coming from
         vec3.scale(adjustedLD, -1);
         // push it up to the shader
         gl.uniform3fv(prog.lightingDirectionUniform, adjustedLD); 

         // push directional lighting colour up to the shader
         gl.uniform3f(prog.directionalColorUniform, 0.7, 0.7, 0.7);

         gl.uniform3fv(prog.greyingFactor, planet.getGreyingFactor()); 
       };

    dummy.initUniforms = function() {
       var prog = this.shaderProgram;
       var gl = this.gl;

       prog.mvMatrixUniform = gl.getUniformLocation(prog, "uMVMatrix");
       prog.pMatrixUniform = gl.getUniformLocation(prog, 'uPMatrix');
       prog.scale = gl.getUniformLocation(prog, 'uScale');
       prog.color = gl.getUniformLocation(prog, 'uColor');
  }

    dummy.initAttributes = function() {
       var prog = this.shaderProgram;
       var gl = this.gl;

       prog.vertexPositionAttribute = gl.getAttribLocation(prog, 'aVertexPosition');
       gl.enableVertexAttribArray(prog.vertexPositionAttribute);
    }

    dummy.initProgVars = function(planet){
         var r = planet.color[0] / 255;
         var g = planet.color[1] / 255;
         var b = planet.color[2] / 255;
         var a = planet.color[3] / 255;
         this.gl.uniform4fv( this.shaderProgram.color, [r,g,b,a]);
   };

    var getSunImageUrl = function() {
       if (isOffline() ){
         return 'http://0.0.0.0:5000/static/happy_melon.gif';
       } else {
         return 'http://www.mathematik.uni-marburg.de/~menzel/images/Tutorial_Sun/SunTexture_2048.png';
       }
    };

    var getPlanetTextureUrl = function(videoRef) {
       if (isOffline() ){
            return 'http://0.0.0.0:5000/static/happy_melon.gif?foo=' + videoRef;
       } else {
            return 'http://streaming.vikkiread.co.uk.s3.amazonaws.com/' + videoRef + '.jpg';
       }
    };

    function initWorldObjects(vvc) {
        var planet = new Planet(0.1, 0, [0,0,0], getSunImageUrl(), 0.5, [255,255,0,OPAQUE], 'the SUN', null);
        planets.push(planet);

        var maxShareCount = 0;
        var totalShareCount = 0;
        for (var i = 0; i < 10; i++) {
           if (vvc.entries[i].shares > maxShareCount){
              maxShareCount = vvc.entries[i].shares;
           }
           totalShareCount += vvc.entries[i].shares;
        }

        var allowForSun = 0;
        var maxDistFromSun = 25;

        var outSoFar = allowForSun;
        for (var i = 0; i < 10; i++) {
            var entry = vvc.entries[i];

            var sharePerc = entry.shares / totalShareCount;

            var startingAngle = 0.2*i;
            var rTri = Math.PI*2 * sharePerc;

            var thisDist = sharePerc*(maxDistFromSun-allowForSun);
            var dist = thisDist + outSoFar;
            var distFromCentre = [dist, 0.0, dist];
            outSoFar += thisDist;

            var scale = sharePerc + 1.5;

            var randColor = [randPrimaryColor(), randPrimaryColor(), randPrimaryColor(), OPAQUE];

            var planet = new Planet(rTri, startingAngle, distFromCentre, getPlanetTextureUrl(entry.videoRef), scale, randColor, entry.title, entry.hostingSiteUrl, entry.videoRef);
            planets.push(planet);
        }   
    }

// could probs do this with a shiny js api?? the offline api perhaps :P TODO
var isOffline = function() {
    return document.location.hash === '#offline';
};

var matchVideo = function(fromUrl) {
  if (isOffline()) {
     return fromUrl;
  } else {
     return fromUrl;
     var realUrlMatch =   fromUrl.match(/kitty\?img=([^&]*)&?/);
     if(realUrlMatch && realUrlMatch.length > 0) {
        realUrl = realUrlMatch[1];
     }
  }
};

var getVideoLocation = function(videoRef) {
  return isOffline() ? videoRef :  ' /kitty?img=' + videoRef;
} ;

var planets = [];

function drawVid(videoRef) {
       var vid = document.createElement('video');
       vid.id = 'video' + videoRef;
       // TODO unhorrible - use css
       vid.style.display = 'none';
       vid.height = '256'; 
       vid.width  = '256'; 
       vid.className = 'vidTexture';
       //vid.src = '/yt_vid?vid=' + videoRef;
       vid.src = '/vid?vid=http://streaming.vikkiread.co.uk.s3.amazonaws.com/' + videoRef + '.mp4';
       document.body.appendChild(vid);
       return vid;
}

function drawVidEmbed(videoRef) {
   var embed = createYTEmbed(videoRef);
}

function removeOldVidEmbeds(current) {
   // call stop  + remove old video elements - hopefully this prevents mem leakages? 
   var vidTextures = document.querySelectorAll('.vidTexture');
   for (var i = 0; i < vidTextures.length; i++) {
      var vid = vidTextures[i];
      if (vid == current)  {
         continue;
      }
      vid.pause();
      // http://blog.pearce.org.nz/2010/11/how-to-stop-video-or-audio-element.html
      vid.src = '';
      vid.currentSrc = '';
      vid.load();
      vid.parentElement.removeChild(vid);
   }
}

var getJsonUrl = function() {
    if (isOffline() ) {
       return "/static/fake.json";
    } else {
       return "/html?html=http://streaming.vikkiread.co.uk.s3.amazonaws.com/current_vvc.json";
    }
};

function setupChartViz(oReq) {
   var vvc = JSON.parse(oReq.responseText);
   console.dir(vvc);
   drawStuff(vvc);
}

function doStuff() {
   doAjaxRequest(getJsonUrl(), setupChartViz);
   // x-browser fail!!! TODO fixme
   document.getElementById('vixgl').addEventListener('click', handleClick, false);
}

function getNewPlanetFromImageUrl(imgToMatch) {
  return getFirstMatching(planets, Planet.prototype.equalsImageUrl, imgToMatch);
}

function getPlanetFromColor(colorToMatch) {
   return getFirstMatching(planets, Planet.prototype.equalsColor, colorToMatch);
}

function handleClick(e) {
   var coords = relMouseCoords(event);
   var col = getColorFromCoords(coords, dummy.gl);
   var planet = getPlanetFromColor(col);
   console.log('from ' + col[0] + ',' + col[1] + ',' + col[2] + ',' + col[3] + ' got ' + (planet ? planet.title : '')); 
   var toShow = planet ? planet.title : 'the VOID....';

   // TODO this is sucky - change it - see def in planets.js
   Planet.prototype.stopSpinning = false;
   document.getElementById('whoo').innerText = 'i am embarassingly happy that you clicked on ' +  toShow;

   for (var i in planets) {
      planets[i].vidding = false;
      planets[i].greyed = (typeof planet != 'undefined'); 

      proper.updateTextureWith(planets[i].origTex, planets[i].texture);
   } 

   removeOldVidEmbeds(vid); 

   if (planet) {
      var vid = document.getElementById('video' + planet.videoRef);
      var vid = drawVid(planet.videoRef);
      planet.vidding = true;
      planet.greyed = false;
   } 
}

</script>

<style>
   #vixgl {
     /*background-image: url('http://www.ilovemydesktop.com/data/media/14/Nebula_Space.jpg');*/
     background-color: black;
   }

   #dummygl {
      display:none;
   }
</style>

</head>

// TODO oh fucking hell use a proper loader
<body onload="doStuff()">
  <canvas id="vixgl" width="1600" height="400" >
  </canvas>
  <canvas id="dummygl" width="1600" height="400" >
  </canvas>
  <p id='whoo'></p>

  <div id="embedBackground" width="1600" height="400" style="display:none">
  </div>
</body>
</html>
